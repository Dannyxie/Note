#CSS: The Definitive Guide

##Chapter 1 CSS and Documents
###Elements
- `Elements` are the basis of document structure.

###Replaced and Nonreplaced Elements
- elements generally take two forms: replaced and nonreplaced

####Replaced elements
- **Replaced elements** are those where the element's content is replaced by something that is not directly represented by document content. such like `img`,`input`

####Nonreplaced elements
- **Nonreplaced elements** mean that their content is represented by the user agent(generally a browser) inside a box generated by the element itself.( This is true of paragraghs, headings, table cells, lists, and almost everything else in XHTML.)

###Element Display Roles
- In addition to replaced and nonreplaced elements, CSS2.1 uses two other basic types of elements: **block-level** and **inline-level**.

####Block-level elements
- **Block-level elements** generate an element box that(by default) fills its parent element's content area and cannot have other elements at its sides.(`p`,`dic`,etc). Replaced elements can be block-level elements, but they usually are not.
- List items are a special case of block-level elements. In additon to behaving in a manner consistent with other block elements, they generate a marker--typically a bullet for unoredered lists and a number for oreder lists--that is "attached" to the element box. Except for the represence of this marker, list items are in all other ways identical to other block elements.

####Inline-level elements
- **Inline-level elements** generate an element box within a line of text and do not break up the flow of that line ( `a`,`strong`, `em`, etc). These elements do not generate a "break" before or after themselves, so they can appear within the content of another element without disrupting its display.
  

- In HTML and XHTML, block-level elements cannot descend from inline-level elements. In CSS, there is no restriction on how display roles can be nested within each other.
- Typically, the XHTML hierarchy works out such that inlines can descend from blocks, but no the other way around. CSS, on the other hand, has no such restrictions.

###Bringing CSS and XHTML Together
- documents are supported to have an internal structure, which is altogether different than a visual structure.
 
###The link Tag
`<link rel="stylesheet" type="text/css" href="shee1.css" media="all" />`

- To successfully load an external style sheet, **link** must be placed inside the **head** element but may not be placed inside any other element, rather like title. This will cause the web browser to locate and load the style sheet and use whatever styles it contains to render the HTML document.
-  No XHTML or any other markup languague can be included in the style sheet-- only style rules.
- An external style sheet cannot contain any document markup at all, only CSS rules and CSS comments. The presence of markup in an external style sheet can cause some or all of it to be ignored.
- The filename extension is not required, but some older browser won't recognize the file as containing a style sheet unless it actually ends with **.css**. In fact, some web servers won't hand over a file as **text/css** unless its filename ends with **.css*, though that can usually be fixed by changing the server's configuration files.

####Attribute
- type is always set to **text/css**. This value describes the type of data that will be loaded using the **link** tag.

**media** attribute:
	all: Use in all presentational media
	print: Use when printing the document for sighted users and also when displaying a "print preview" of the document.
	screen: Use when presenting the document in a screen medium like a desktop computer monitor. All web browsers running on such systems are screen-medium user agents.

###The style element
- The style element should always start with `<style type="text/css">`, it is possible to be given a **media** attribute.
- The style between the opening and closing style tags are referred to  as the *document style sheet*, or the *embedded style sheet* since this style sheet is embedded within the document. 

###The @import Directive
- `@import url(sheet2.css)`
- `@import` can be used to direct to web browser to load an external style sheet and use its styles  in rendering of the HTML document. `@import` must be placed inside the `style` container
- the style sheets of every @import directive will be loaded and used; (no way to designate alternate style)
- We can restrict imported style sheets to one or more media by listing the media to which it should be applied after the style sheet's URL: `@import url(shee2.css) all;`,`@import url(blueworld.css) screen;`
- External style sheets cannot contain any document makrup, the `link` element can'y be used -- but `@import` can.
- `@import` also directives appear at the beginning of the style sheet. CSS requires the `@import` directive to come before any other rules in a style sheet. An @import that comes after other rules will be ignored by conforming user agents.
- Internet Explorer for Whindows does not ignore any @import directive, even those that come after other rules.

###Backward accesibility

###CSS Comments
`/* This is a CSS1 comment */`

###Inline Styles
- we can't put an `@import` into a `style` attribute
- Use of the `style` attribute is not generally recommended. Indeed, it is marked as deprecated by XHTML 1.1 and is very unlikely to appear in XML languages other than XHTML. Some of the primary advantages of CSS -- the ability to organize centralized styles that control an entire document's appearance or the apperance of all documents on a web server -- are negated when you place styles into a `style` attribute 
	

###Summary



##Chapter 2 Selctors

###Declarations and Keywords
- In the CSS property font, there is exactly one place where a forward slach (/) can be used to seperate two specific keywords. `h2 {font: large/150% sans-serif;}`. This is the only place the slash is allowed to appear in the `font` declaration.


###Multiple Classes
- `.warning.urgent{ background:silver;}`
- If a multiple class selector contains a name that is not in the space-separated list then the match will fail: `p.warning.help{ background:red;}` It will match a `p` element with both class `warning` and `help`: `<p class="urgent warning help">Help me!</p>
- In versions previous to IE7, Internet Explorer for both paltforms has problems with correctly handling multiple class selectos. In there older versions, although you ca select a single class name out of a list, selecting based on multiple names in a list does not work properly. Thus, `p.warning` would work as expected, but `p.warning.help` would match any `p` elements that have a `class` attribute with the word `help` because it comes last in the selector. If you wrote `p.help.warning`, then older versions of Explorer would match any `p` elements that have `warning` in their class value, whether or not `help` appears in the same value.


###Deciding Between Class and ID
- In the real world, browser don't usually check for the uniqueness of IDs in HTML, which means that if you sprinkle an HTML document with several elements, all of which have the same value for their ID attributes, you'll probably get the same styles applied to each. This is incorrect behavior, but it happens anyway. Having more that one of the same ID value in a document also makes DOM scripting more difficult, since function like `getElementById()` depend on there being one, and only one, element with a given ID value.
- ID selectors can't be combined, since ID attributes do not permit a space-separated list of words.
- class and ID selectors may be case-sensitive, depending on the document language. HTML and XHTML define class and ID values to be case-sensitive.

###Selection Based on Partial Attribute Values
- `~` is the key to selection based on the presence of a space-separated word within the attribute's value. `p[class~="warning"]{ font-weight: bold;}`

###Understanding the Parent-Child Relationship
- An element is said to be the parent of another element if it appears directly above that element in the document hierarchy
- An element is the child of another element if it is directly beneath the other element.
- THe terms parent and child are specific applications of the terms `ancestor` and `descendant`. In the tree view, if an element is exactly one level above another, then they have a parent-child relationship. If the path from one element to another continues through two or more levels, the elements have an ancestor-descendant relationship, but not a parent-child relationship.(Of course, a child is also a descendant, and a parent is an ancestor.)

###Descendant Selectors
- `:link` refers to links to resources that haven't been visited.

###Selecting Adjacent Sibling Elements
- To select an element that immediately follows another element with the same parent, you use the `adjacent-sibling combinator`, represented as a plus symbol (+).
- Internet Explorer for Windows through IE6 does not support child and adjacent-sibling selectors. IE7 supports both.

###Pseudo-Classes 
- CSS defines pseudo-classes that make the anchors to visited pages act as though thay have classes of "visited" `a:visited {color:red;}`. The colon separating the a and the visited is the calling card of a pesudo-class or pseudo-element. All pseudo-class and -element keywords are preceded by a colon.

####Link pseudo-classes

|Name|Description|
|----|----------|
|:link| Refers to any anchor that is a hyperlink(i.e., has an *href* attribute) and points to an address that has not been visited. Note that some browsers may incorrectly interpret `:link` to refer to any hyperlink, visited or unvisited.|
|:visited| Refers to any anchor that is a hyperlink to an already visited address|

 
###Dynamic pseudo-classes
|name|Description|
|----|-------|
|:focus| Refers to any element that currently has the input focus -- i.e., can accept keyboard input or be activated in some way.|
|:hover| Refers to any element over which the mouse pointer is placed --e.g., a hyperlink over which the mouse pointer is hovering.|
|:active| Refers to any element that has been activated by user input --e.g., a hyperlink on which a user clicks during the time the mouse button is held down.|

- THe dynamic pseudo-classes can be applied to any element.
- IE6 does not permit dynamic pseudo-classes to select any elements other that hyperlinks. IE7 added support for `:hover` on any element, but not `:focus` styles for form elements.

###Selecting a first child
- `:first-child`, is used to select elements that are the first children of other elements. support: IE7+

###Selecting based on language
-  In terms of its matching patterns, the `:lang()` pseudo-class is exactly like the |= attribute selector. `*:lang(fr) { font-style: italic;}`

- The primary difference between the pseudo-selector and the attribute selector is that the language information can be derived from a number of sources, some of which are outside the element itself.

###Combining pseudo-classes
- With CSS2.1, we can combine pseudo-classes in the same selector: `a:link:hover{color:red;}` exclusive pseudo-classes can to be combine together.
- IE6 just pay attention to the last of the combined pseudo-classes.

###Pseudo-Element Selectors

####Styling the first letter
- The first pseudo-element styles the first letter, and only that letter, of a block-level element. `p:first-letter { color:red;}`

####Styling the first line
- The  style is applied to  the first displayed line of text in each paragraph. This is true no matter how wide or narrow the display region is.  

####Restriction on :first-letter and :first-line
- In CSS2, the `:first-letter` and `:first-line` pseudo-element can be applied only to block-level elements such as headings or paragraphs and not to inline-level elements such as hyperlinks. In CSS2.1, `:first-letter` applies to all elements. 

Properties permitted on pseudo-elements

|:first-letter 		|	: first-line 	|
|-------------		|----------		|
|All font properties 	| All font properties 	|
| color 		| color 		|
| All background properties 		| All background properties|
| All margin properties 		| word-spacing 	|
| All padding properties 		| letter-spacing 		|
| All border properties 		| text-decoration 		|
| text-decoration 	| vertical-align 	|
| vertical-algin( if float is set to none) 	|  text-transform 	|
| text-transform 	| line-height 		|
| line-height 		| clear(CSS2 only; removed in CSS2.1 |
| float 		| text-shadow(CSS2 only)|
| letter-spacing(added in CSS2.1) |	|
| word-spacing(added in CSS2.1)	|	|
| clear(CSS2 only; removed in CSS2.1) 	|	|
| text-shadow(CSS2 only) | |

- In addition, all pseudo-elements must be placed at the very end of the selector in which they appear. Therefore, it would not be legal to write `p:first-line em` since the pseudo-element comes before the subject of the selector( the subject is the last element listed). The same rule applies to the other two pseudo-elements CSS2.1 defines.

###Summary

##CHAPTER 3 Structure and the Cascade

###Specificity

- The actual specificity of a selector is determined as follow:

	- For every ID attribute value given in the selector, add 0,1,0,0.
	- For every class attribute value, attribute selection, or pseudo-class given in the selection, add 0,0,1,0.
	- For every element and pseudo-element given in the selector, add 0,0,0,1. CSS2 contradicted itself as to whether pseudo-elemens had any specificity at all, but CSS2.1 makes it clear that they do, and this is where they belong.
	- Combinations and the universal selector do not contribute anything to the specificity ( more on these values later).


###Declarations and Specificity
- Once the specificity of a selector has been determined, the value will be conferred on all of its associated declarations.

###Universal Selector Specificity
- The universal selector does not contribute to the specificity of a selector.

###ID and Attribute Selector Specificity

###Inline Style Specificity

###Importance

###Inheritance
- Inheritance is the mechanism by which styles are applied not only to a specified element, but also to its descendants.
- background styles applied to the `body` element can be passed to the `html` element, which is the document's root element and therefore defines its canvas
- Property `border` does not inherit
- Most of the box-model properties -- including margins, padding, backgrounds, and borders -- are not inherited. 
- Inherited values have no specificity at all, not even zero specificity.

###The cascade
- The later a declaration appears in the style sheet or document, the more weight it is given. Declarations that appear in an imported style sheet are considered to come before all declarations within the style sheet that imports them.

###Sorting by Weight and Origin
- To sum up, there are five levels to consider in terms of declaration weight. ON order of most to least weight, these are:

	1. Reader important declarations.
	2. Author important declarations.
	3. Author normal declarations.
	4. Reader normal declarations
	5. User agent declarations

##CHAPTER 4 Values and Units

###Numbers
- There are two types of numbers in CSS: `interger` ("Whole" numbers) and `reals` (fractional numbers).


##CHAPTER 6 Text Properties 


###Indenting Text

	text-indent
	Values: <length> | <percentage> | inherit
	Initial value: 0
	Applies to: Block-level elements
	Inherited: Yes
	Percentages: Refer to the width of the containing block
	Computed value: For percentage values, as specified; for length values, the absolute length

- text-align can be applied to any block-level element, but it can't be applied to inline elements or on replaced elements such as images.
-  to "indent" the first line of an inline element, use left padding or margin.


###Horizontal Alignment
	text-align
	CSS2.1 values: left | center | right | justify | inherit
	CSS2 values: left | center | right | justify | <string> | inherit
	Initial value: User agent-specific; may also depend on writing direction
	Applies to: Block-level elements
	Inherited: Yes
	Computed value: As specified
	Note: CSS2 included a <string> value that was dropped from CSS2.1 due to
	a lack of implementation

![](http://i.imgur.com/yeGRrXZ.png)

- text-align does not control the alignment of elements, only their inline content. The actual elements are not shifted from one side to the other. Only the text within them is affected
- IE6 treat text-align:center as if it were the <center> element, and centers elements as well as text. This does not happen in standards mode in IE6 and later, but it persists in IE5.x and earlier.


####text-align:justify
- In justified text, both ends of a line of text are placed at the inner edge of the parent element. Then, the spacing between words and letters is
adjusted so that each line is precisely the same length. Justified text is common in the print world.


###Vertical Alignment

####The Height of Lines
- `line-height` controls the *leading*, which is the extra space bewtween lines of text above and beyond the font's size.

	line-height
	Values: <length> | <percentage> | <number> | normal | inherit
	Initial value: normal
	Applies to: All elements (but see text regarding replaced and block-level elements)
	Inherited: Yes
	Percentages: Relative to the font size of the element
	Computed value: For length and percentage values, the absolute value; otherwise, as specified

- When applied to a block-level element, `line-height` defines the minimum distance between text baselines within taht element.  

####Constructing a line
-  Every element in a line of text generates a *content* area, which is determined by the size of the font. This content area in turn generates an *inline* box that is, in the absence of any other factors, exactly equal to the content area. The leading generated by `line-height` is one of the factors that increates or decreates the height of each inline box.

###Vertically Aligning Text
- In CSS, the `vertical-align` property applies only to inline elements and replaced elements such as images and form inputs. `vertical-algin` is not an inherited property.
- `vertical-algin` does not affect the alignment of content within a **block-level** element.

####Baseline alignment
- `vertical-align: baseline` forces the baseline of an element to align with the baseline of its parent. If a vertically aligned element doesn't have a baseline--that is, if it's an image, a form input, or another replaced element--the the bottom of the element is aligned with the baseline of its parent.
- This alignment rule is important because ist causes some web browsers to always put a replaced element's bottom edge on the baseline, even if there is no other text in the line

####Superscripting and subscripting
- The declaration `vertical-align sub` causes an element to be subscripted, meaning that its baseline (or bottom, if it's a replaced element) is lowered with respect to its parent's baseline. The specification doesn't define the distance the elment is lowered, so it may vary depending on the user agent.
- `super` is the opposite of `sub`; it raises the element's baseline( or bottom of a replaced element) with respect to the parent's baseline. again, the dispance the text is raised depends on the user agent.
-  The values `sub` and `super` do not change the element's font size, so subscripted or superscripted text will no become smaller(or larger). 

####Bottom feeding
- `vertical-align:bottom` aligns the bottom of the element's inline box with the bottom of the line box.
- `vertical-align:text-bottom` refers to the bottom of the text in the line. For the purposes of this value, replaced elements, or any other kinds of non-text elements, are ignored. Instead, a "default" text box is considered. This default box is derived from the `font-size` of the parent element. The bottom of the aligned element's inline box is then aligned with the bottom of the default text box.

####Getting on top 
- Employing `vertical-align:top` has the opposite effect of bottom. Likewise, `vertical-align:text-top` is the reverse of text-bottom.



###Word Spacing and Letter Spacing

####Word Spacing
- The `word-spacing` property accepts a positive or negative length. This length is added to the standard space between words. In effect, `word-spacing` is used to modify interword spacing. Therefore, the default value of normal is the same as setting a value of zero(0).

###Spacing and Alignmenet
- The value of `word-spacing` may be influecned by the value of the property `text-align`

###Text Transformation
- `uppercase` and `lowercase` convert text into all upper- or lowercase characters. `capitalize` capitalizes only the first letter of each word.

###Text Decoration

###Text Shadow

###Handling Whitespace
- `white-space` affects the user agent's handling of space, newline, and tab characters within the document source.
- To a certain extent, default XHTML handling already does this: it collapses any whitespace down to a single space. 
- `whitespace:nowrap;` means that the only way to end a line is to insert a line-break element. If no such element is inserted, then the line will go forever, forcing the user to scroll horizontally to read whatever can't be initially displayed `<br/>` in the the browser window. 
- If an element is set to `pre-wrap`, then text within that element has whitespace sequences preserverd, but text lines are wrapped normally.  With this value, line-breaks in the source and those that are generated are also honored. `pre-line` is the opposite of `pre-wrap` and causes whitespace sequences to collapse as in normal text but honors new lines.


| Value | Whitespace | Linefeeds | Auto line wrapping |
| ----- | ----- | ----- | ----- |
| pre-line | Collapsed | Honored | Allowed |
| normal | Collapsed | Ignored | Allowed |
| nowrap | Collapsed | Ignored | Prevented |
| pre 	 | Preserved | Honored | Prevented |
| pre-wrap | Preserved | Honored | Allowed |



###Text Direction
- The `direction` property affects the writing direction of text in a block-level element, the direction of table column layout, the direction in which content horizontally overflows its element box, and the position of the last line of a fully justified element.


##CHAPTER 7 Basic Visual Fomatting
###Basic Boxes
- CSS assumes that every element generates one or more rectangular box, called `element box`. Each element box has a `content area` at its core.
- If no color is set, then the border takes on the foreground color of the element's content
- If a border style has gaps of some type, then the element's background is visible through those gaps.

###The Containing Block
- For an element in the normal, Western-style flow of text, the containing block the formed by the `content edge` of the nearest block-level, table cell, or inline-block ancestor box.


- Most elements are in the normal flow, and the only way for an element to leave it is to be floated or positioned.

###Block-level Elements
- In general the `width` of an element is defined as the distance from the left inner edge to the right inner edge, and the `height` is the distance from the inner top to the inner bottom

###Horizontal Fomatting
- The sum of the horizontal components of a block-level element box  in the normal flow always equals the `width` of the parent.

####Horizontal properties
- "seven properties": `margin-left`,`border-left`,`padding-left`,`width`,`padding-right`,`border-right`, and `margin-right`
- block-level elements nearly always have block-level elements for parents
- Only three may be set to auto: `width`, `margin-left`, `margin-right`. 
- `width` must either be set to `auto` or a nonnegative value of some type.

####Using auto
- three properties that can be applied `auto`: `width`, `margin-left`, or `margin-right`
- If you set `width`, `margin-left`, or `margin-right` to a value of `auto`, and give the remaining two properties specific values, then the property that is set to `auto` determines the length required to make the element box's width equal to the parent element's `width`.
- In the case where all three properties are set to something other than `auto` --  or, in CSS terminology, when these formatting properties have been `overconstrained`-- the `margin-right` is always forced to be `auto`.
- `margin-right` is forced to be `auto` only for **left-to-right** languages such as English. In **right-to-left** languages, everything is reversed, so `margin-left` is forced to be `auto`, not `margin-right`.
- If both margins are set explicitly, and `width` is set to `auto`, then the value of `width` will be set to whatever value is needed to reach the required total(which si the content width of the parent element).
- If both margins are set to auto, then they are set to equal lengths.
- Setting both margins to equal lengths is the correct way to center elements, as opposed to using `text-align`. ( text-align applies only to the inline content of a block-level element)
- Set one of the margins and the width to `auto`, the margin set to `auto` is reduced to zero.
- When all three properties are set to `auto`, both margins are set to zero, and the width is made as wide as possible.
- Since horizontal margins do not collapse, the paddding, borders, and margins of a parent element can affect its children. The effect is indirect in that the margins( and so on ) of an element can induce an offset for child elements.

####Negative margins
- The total of the seven horizontal properties always equals the width of the parent element. As long as all properties are zero or greater, an element can never be wider that its parent's content area.
- Padding, borders, and content widths( and heights) can never be negative. Only margins can be less that zero.

####Percentages
- Borders cannot have percentage widths, only lengths.

####Replaced elements
- Replaced block-level elements: if `width` is left as `auto`, then the width of the element is the content's intrinsic width.
- When a replaced element's width is changed from its intrinsic width, the value of height is scaled to match, unless height has been set to an explicit value of its own. The reverse is also true.

###Vertical Formatting
- The default height of an element is determined by its content. Height is also affected by the width of the content; the skinnier a paragraph becomes, the taller it must be to contain all of the inline content within it.
- When the `height` is less than what is needed to display the content, the browser may add a scrollbar to the element. ( depend on the value of the property `ovverflow`)
- `height` defines the content area's height, not the height of the visible element box. Any padding, borders, or margins on the top or bottom of the element box are added to the value for height.

####Vertical properties
- Vertical formatting has seven related properties: `margin-top`, `border-top`, `padding-top`, `height`, `padding-bottom`, `border-bottom`, and `margin-bottom`
- Only three properties may be set to auto: the height of the element's content and the top and bottom margins. The top and bottom padding and borders must be set to specific values or else they default to a width of zero. (Assuming no `border-style` is declared). If `broder-style` has been set, then the width of the borders is set to be the vaguely defined value medium.
- If either `margin-top` or `margin-bottom` is set to `auto` for a block element in the normal flow, it automatically evaluates to **0**.
- `height` must be set to `auto` or to a nonnegative value of some type.

####Percentage heights
- If the `height` of a block-level, normal-flow element is set to a percentage, then that value is taken as a percentage of the height of the containing block.
- In cases where the `height` of the containing block is not explicitly declared, percentage heights are reset to auto.


####Auto heights
- A block-level, normal-flow element with `height: auto` is rendered just hight enough to enclose the line boxed of its inline content (including text)
- auto height sets a border on a paragraph and assumes no padding--expect the bottom border to go just under the bottom line of text and the top border to go just above the top line of text.
- If an auto-height, block-level, normal-flow element has only block-level childlren, then its default height will be the distance from the top of the topmost block-level child's outer border edge to the bttom of the bottommost block-level child's outer border edge.
- If a block-level element has either top or bottom padding, or top or bottom borders, then its height will be the distance from the top of the outer top margin edge of its topmost child to the outer bottom margin edge of its bottommost child.

####Collapsing vertical margins
- Collapsing behavior applies only to margins. Padding and borders, where they exist, are never collapsed by anything.(overlap)
- The smaller of the two magins is eliminated in favor of the larger

####Negative margins
- If negative vertical margins are set, then the browser should take the absolute maximum of both margins. The absolute value of the negative margin is then substracted from the positive margin. In other words, the negative is added to the positive, and the resulting value is the distance between the elements.


###Inline Elements
- The content area is analogous to the content box of a block-level element.
- The background of an inline element is applied to the content area plus any padding
- Any border on an inline element surrounds the content area plus any padding and broders.
- Padding, borders, and margins on nonreplaced elements have no vertical effect on inline elements or the boxes they generate; that is, they do no affect the height of an elements's inline box( and thus the line box that contains the elements).
- Margins and borders on replaced elements do affect the height of the inline box for that elemen and, by implication, the height of the line box for the line containing the element.
- Inline boxes are vertically aligned within the line according to their values for the property `vertical-align`


###Basic Term and Concepts
- For nonreplaced elements, the height of the **inline box** of an element will be exactly equal to the value for `line-height`. For replaced elements, the height of the inline box of an element will be exactly equal to the content area since leading is not applied to replaced elements.
- The top edge of the **line box** is placed along the top of the highest inline box top, and the bottom of the **line box**  is placed along the bottom of the lowest inline box bottom

###Inline Formatting
- All elements have a `line-height`
- A line's height ( or the height of the line box) is determined by the height of its constituent elements and other content, such as text.
- `line-height` actually affects inline elements and other inline content, not block-elements--at least, not directly.
- Declaring `line-height` on a block-level element sets a minimum line-box height for the content of that block-level element.

###Inline Nonreplaced Elements

####Building the boxes
- For an inline nonreplaced element or pieve of anonymous text, the value of `font-size` determines the height of the conent area.
- The line box is defined as the distance from the top of the highest inline box in the line to the bottom of the lowest inline box, and the top of each line box butts up against the bottom of the line box for the preceding line.

####Vertical alignment

The effects of the assorted keyword values of `vertical-align` are:
	top: Aligns the top of the element's inline box with the top of the containing line box.
	bottom: Aligns the bottom of the element's inline box with the bottom of the containing line box.
	text-top: Aligns the top of the element's inline box with the top of the parent's content area.
	text-bottom: Aligns the bottom of the element's inline box with the bottom of the parent's content area.
	middle: Algins the vertical midpoint of the element's inline box with a poing one-half ex above the baseline of the parent.
	super: Moves the content area and inline box of the element upward. The distance is not specified and may vary by user agent.
	sub: The same as super, except the element is moved downward instead of upward
	<percentage> : Shifts the element up or down the distance defined by taking the declared percentage of the element's value of `line-height`



###Inline Replaced Element
- Inline replaced element, such as images, are assumed to have an intrinsic height and width.
- A replaced element with an intrinsic height can cause a line box to become taller than normal. This does no change the value of `line-height` for any element in the line, including the replaced element itself. Replaced element can increase the height of the line box but not the value of line height.

####Adding box properties
- Padding and borders are applied to replaced elements as usual; These two thing acutally influence the height of the line box because they are part of the inline box of an line replaced element( unlike inline nonreplaced elements)
- Negative margins are the only way  to cause inline replaced elements to bleed into other lines.

####Replaced elements and the baseline
- Replaced elements do not actually have baselines of their own, so the next best thing is to align the bottom of their inline boxes with the baseline.
- An image placed in a table cell all by itself should make the table cell tall enough to contain the line box containing the image


###Inline-Block Elements
- An inline-block element relates to other elements and content as an inline box. In other words, it's laid out in a line of text just as an image would be, and, in fact, inline-block elements are formatted within a line as a replaced element. This means the bottom of the inline-blovk element will rest on the baseline of the text line by default and will not line-break within itself.
- Inside the inline-blovk element, the content is formatted as thought the element were block-level.
- If an inline-block element's width is not defined or explicitly declared auto, the element box will shrink to fit the content.

##CHAPTER 8 Padding, Borders, and Margins

###Basic Element Boxes
- Boxes can overlap if they have been manually positioned, and visual overlap can occur if negative margins are used on normal-flow elements.

###Width and Height
- `width` and `height` don't apply to inline-nonreplaced elements. (they apply to Block-level and replaced elements)

Problem( Both of these behaviors were fixed in IE6, but only in "standard" mode. "quirks" mode will still use the previously described behaviors.):
	
	- IE/Win used `width` and `height` to define the dimensions of the visible element box, not the content of the element box. In other words, IE6/Win used `width` to describe the total of the element's content area, left and right padding, and left and right border.
	- IE/Win applied `width` and `height` to inline nonreplaced elements.

###Margins Versus Padding
- Background will extend into the padding but not the margin

###Margins

###Length Values and Margins

###Pecentages and Margins
- Pencentage margin(top and bottom) relate to the `width` of the parent, not the `height`

###Replicating Values

	1. If the value for *left* is missing, use the value provided for *right*
	2. If the value for *bottom* is missing, use the value provided for *top*
	3. If the value for *right* is missing, use the value provided for *top*


###Single-Side Margin Properties

###Negative and Collapsed Margins
- Vertically adjacent margins in the normal flow will collapse.

###Margins and Inline Elements
- Applying the margins to an inline nonreplaced element, it will have absolutely no effect on the line height. Margins are effectively transparent, this declaration will have no visual effect whatsoever. Margins on inline nonreplaced elements don't change the line height of an element.
- The only properties that can change the distance between lines **containing only text** are `line-height`, `font-size`, and `vertical-align`.
- When an inline nonreplaced element with a margin is displayed across multiple lines, the left margin is applied to the beginning of the element and the right margin to the end of it. Margins are not applied to the right and left side of each line. Margins only affect line breaking by changing the point at which the element's content begins within a line
- When apply negative margins to inline nonreplaced elements. The top and bottom of the element aren't affected, and neither are the heights of lines, but the left and right ends of the elements can overlap other content 
- Margins set on replaced elements do affect the height of a line. The left and right margins of an inline replaced element act the same as for a nonreplaced element

###Borders
- Every border has three aspects: its width, or thickness; its style, or appearance; and its color. 
- The default value for the width of a border is `medium`, which is no explicitly defined but is usually two pixels. The default style for borders is `none`. The default border color is the foreground color of the element itself. If no color has been declared for the border, it will be the same color as the text of the element. If the element has no text, the border color will be the text color of its parent element(due to the fact that color is inherited)

###Borders and Backgrounds
- The background of an element extends to the outside edge of the border. The element's background should appear in the spaces between the visible protions of the border.
- CSS2.1 explicitly states that the element's background is the background of the content, apdding, and border areas.

###Borders with Style
- Without a style, there wouldn't be any border at all.
- The style value `hidden` is equivalent to `none`, except when applied to talbes.
- `double`: the width of the two lines, plus the width of the space between them, is equal to the value of `border-width`. When a border-width is set for `double`, border thickness, or space between two line, are decided by the user agent.

####Multiple styles
- order: top-right-bottom-left.

####Single-side styles

###Border Widths
- Since the default value of `border-style` is none,failing to declare a style is exactly the same as declaring `border-style:none`. Therefore, if you want a border to appear, you must declare a border style.

###Border Colors
- The default color is the foreground color of the element.

####Transparent borders
- `border-color:transparent;` : be used to create an invisible border that has width.
- Support for `transparent` is not present in versions of IE/Win before IE7. In the affected versions, IE will instead base the border color on the element's color value

###Shorthand Border Properties

###Borders and Inline Elements
- No matter how thick you make your borders on inline elements, the line height of the element won't change. This is true only for the top and bottom sides of inline elements; If you apply a left or right border, not only will it be visible, but it will displace the text around it. 

###Padding
- By default, elements have no padding.
- Padding does not collapse.

###Percentage Values and Padding

###Padding and Inline Elements
- As with margins, the left padding is applied to the beginning of the elements, and the right padding to the end of it; However, padding is not applied to the right and left side of each line. The same holds true for replaced elements as well, although of course such elements don't break acoss lines.

###Padding and Replaced Elements.
- Regardless of whether the replaced element is block-level or inline, the padding will surround its content, and the background color will fill into that padding.


##CHAPTER 9 Colors and Backgrounds

##CHAPTER 10 Floating and Positioning
- Floating is not exactly positioning, but it certainly isn't normal-flow layout either.

###Floating

###Floated Elements
- A floated element is, in some ways, removed from the normal flow of the document, although it still affects the layout. In a manner utterly unique within CSS, floated elements exist almost on their own plane, yet they still have influence over the rest of the document.
- Margins around floated elements do no collapse.
-  If you do float a nonreplaced document, you must declare a `width` for that element. Otherwise, according to the CSS specification, the element's width will tent toward zero.

####No floating at all
- `float:none` is used to prevent an element from floating at all

###Floating: The Details
- A floating element's containing block is the nearest block-level ancestor element.
- A floated element generates a block box, regardless of the kind of element it is.

A series of specific rules govern the placement of floated element:

	1. The left (or right) outer edge of a floated element may not be to the left (or right) of the inner edge of its containing block.
	2. The left (or right) outer edge of a floated element must be to the right (or left) of the right (left) outer edge of a left-floating (or right-floating) element that occurs earlier in the document's source, unless the top of the later element is below the bottom of the former.
	3. The right outer edge of a left-floating element may not be to the right of the left outer edge of any right-floating element to it right. The left outer edge of a right-floating element may not be to the left of the right outer edge of any left-floating element to its left.
	4. A floating element's top may not be higher than the inner top of its parent. If a floating element is between two collapsing margins, it is placed as though it had a block-level parent element between the two elements.
	5. A floating element's top may not be higher than the top of any earlier floating or block-level element.
	6. A floating element's top may not be higer than the top of any inline box containing a box generated by an element that comes earlier in the document source.
	7. A left (or right) floating element that has another floating element to its left (right) may not have its right outer edge to the right (left) of its containing block's right (left) edge.
	8. A floating element must be placed as high as possible.
	9. A left-floating element must be put as far to the left as possible, and a right-floating element as far to the right as possible. A higher position is preferred to one that is further to the right or left.

###Applied Behavior
- A floated element will expand to contain any floated descendants.

###Negative margins
- Negative margins can cause floated elements to move outside of their parent elements.
- If you set the margins to be negative, the content will overrun the outer edge without technically violating the specification.
- When the floated element is wider than its parent. In that case, the floated element will simply overflow the right or left inner edge--depending on which way the element is floated--in its best attempt to display correctly.

###Floats, Content, and Overlapping
- An inline box that overlaps with a float has its borders, background, and content all rendered "on top" of the float.
- A block box that overlaps with a float has its borders and background rendered "behind" the float, whereare its content is rendered "on top" of the float

###Clearing 
- In CSS2.1 clearance is extra spacing added above an element's top margin to push it past any floated elements. This means that the top margin of a cleared element does not change when an element is cleared. Its downward movemenet is caused by the clearance instead.
- The way to make sure a cleared element has some space between its top and the bottom of a float is to put a bottom margin on the float itself.
- The margin edges of a floated element define the edges of the floated box.


###Position

- static(initial value): The element's box is generated as normal. Block-level elements generate a rectangular box that is part of the document's flow, and inline-level boxes cause the creation of one or more line boxes that are flowed within their parent element.
- relative: The element's box is offset by some distance. The element retains the shape it would have had were it not positioned, and the space that it would ordinarily have occupied is preserved.
- absolute: The element's box is completely removed from the flow of the document and positioned with respect to its containing block, which may be another element in the document or the initial containing block. Whatever space the element might have occupied in the normal document flow is closed up, as though the element did not exist. The positioned element generates a block-level box, regardless of the type of box it would have generated if it were in the normal flow.
- fixed: The element's box behaves as though it were set to `absolute`, but its containing block is the viewport itself.

####The containing block
- a float's containing block was defined as the nearest block-level ancestor element.

- The containing block of the "root element" is established by the user agent. In HTML, the root element is the `html` element, although some browsers use `body`. In most browsers, the initial containing block is a rectangle the size of the viewport.
- For a non-root element whose `position` value is `relative` or `static`, the containing block is formed by the content edge of the nearest block-level, table cell, or inline-block ancestor box.
- For non-root elements that have a `position` value of `absolute`, the containing block is set to the nearest ancestor (of any kind) that has a `position` value other that `static`.
	
	- If the ancestor is block-level, the containing block is set to that element's padding edge; in other words, the area that would be bounded by a border.
	- If the ancestor is inline-level, the containing block is set to the content edge of the ancestor. In left-to-right languages, the top and left of the containing block are the top and left content edges of the first box in the ancestor, and the bottom and right edges are the bottom and right content edges of the last box.
	- If there are no ancestors, the element's containing block is defined as the initial containing block.

- Elements can be positioned outside of their containing block.

####Offset properties
- It is possible to set margins, borders, and padding for a positioned element.
- Offset properties difine offset from the analogous side of the containing block, not form the upper-left corner of the contaning block.

###Width and Height

####Setting width and height
- Positioned element's padding is added to the content area, and the content area's size is determined by the values of `height` and `width`.

####Limiting width and height 
- An element's content area can be defined to have a minimum dimension using `min-width` and `min-height` ( applied to all elements except nonreplaced inline elements and table elements

###Content Overflow and Clipping



###Absolute Positioning

####Containing blocks and absolutely positioned elements
- When an element is positioned absolutely, it is completely removed from the document flow. 
- The containing block for an absolutely positioned element is the nearest ancestor element that has a `position` value other than `static`.
- When an element is absolutely positioned, it also establishes a containing block for its descendant elements.

####Placement and sizing of absolutely positioned elements

####Auto-edges
- When an element is absolutely positioned, any of the offset properties other than `bottom` are set to auto.

####Placing and sizing nonreplaced elements
- The width and horizontal placement of a positioned element: **left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = the width of the containing block**


####Placing and sizing replaced elements
1. If `width` is set to `auto`, the used value of `width` is determined by the intrinsic width of the element's content.  
2. If `left` has the value `auto` in a left-to-right language, replace `auto` with the static position. In right-to-left languages, replace an `auto` value for `right` with the static position.
3. If either `left` or `right` is still `auto` (in other words, it hasn't been replaced in a previous step), replace any `auto` on `margin-left` or `margin-right` with 0.
4. If, at this point, both `margin-left` and `margin-right` are still defined to be `auto`, set them to be equal, thus centering the element in its containing block.
5. After all that, if there is only one `auto` value left, change it to equal the remainder of the equation.


Similarly, layout along the vertical axis is governed by a series of rules that state:

1. If `height` is set to `auto`, the computed value of `height` is determined by the intrinsic height of the element's content.
2. If `top` has the value `auto`, replace it with the replaced element's static position.
3. If `bottom` has a value of `auto`, replace any `auto` value on `margin-top` or `margin-bottom` with 0.
4. If, at this point, both `margin-top` and `margin-bottom` are still defined to be `auto`, set them to be equal, thus centering the element in its containing block.
5. After all that, if there is only one `auto` value left, change it to equal the remainder of the equation.

###Fixed Positioning
- Containing block of a fixed element is the viewport. In the case, the element is totally removed from the document's flow and does not have a position relative to any part of the document.
- Fixed positioning is not supported in Internet Explorer for windows prior to IE7.

###Relative Positioning
- When we relatively position an element it immediately establishes a new containing block for any of its children. This containing block corresponds to the place where the element has positioned.
- When is comes to overconstrained relative positioning, one value is reset to be the negative of the other.


##CHAPTER 11 Table Layout

###Visually Arranging a Table
- In CSS, internal table elements generate recangular boxes that have content, padding, andborders, but do not have margins. Therefore, it is not possible to define the separation between cells by giving them margins. A CSS-conformant browser will ignore any attempts to apply margins to cells, rows, or any other internal table element (with the exception of captions)

####Table arrangement rules
- Each row box encompasses a single row of grid cells. All of the row boxes in a table fill the table from top to bottom in the order they occur in the source document (with the exception of any table header or table footer row boxes, which come at the beginning and end of the table, respectively). Thus, the table contains as many grid rows as there are row elements.
- A row group's box encompasses the same grid cells as the row boxes it contains.
- A column box encompasses one or more columns of grid cells. All of the column boxes are placed next to one another in the order they occur.
- A column group's box encompasses the same grid cells as the column boxes that it contains
- Although cells may span several rows or columns, CSS does not define how this happens. Instead, the document language defines spanning. Each spanned cell is a rectangular box on or more grid cells wide and high. The top row of this rectangle is in the row that is parent to the cell. 
- A cell's box cannot extend beyond the last row box of a table or row group. If the table structure would create this condition, the cell must be shortened until it fits within the table or row group that encloses it


###Table Display Values

####Display:

- `table`: This value specifies that an element defiens a block-level table. Thus, it defines a rectangular block that generates a block box.
- `inline-table`: This value specifies that an element defines an inline-level table. This means the element defines a rectangular block that generates an inline box. The closest non-table analog is the value `inline-block`. 
- `table-row`: specifies that an element is a row of cells. The corresponding HTML element is the `tr` element.
- `table-row-group`: specifies that an element groups one or more rows. The corresponding HTML value is `tbody`
- `table-header-group`: This value is very much like `table-row-group`, except that for visual formatting, the header row group is always displayed before all other  rows and row groups and after any top captions. In print, if a table requires multiple pages to print, a user agent may repeat header rows at the top of each page. The specification does not define what happens if you assign `table-header-group` to multiple elements. A header group can contain multiple rows. The HTML equivalent is `thead`
- `table-footer-group`: This value is very much like `table-header-group` , except that the footer row group is always displayed after all other rows and row groups and before any bottom captions. In print, if a table requires multiple pages to print, a user agent may repeat footer rows at the bottom of each page. The specification does not define what happens if you assign `table-footer-group` to multiple elements. This is equivalent to the HTML element `tfoot` 
- `table-column`:
- `table-column-group`
- `table-cell`: This value specifies that an element represents a single cell in a table. The HTML elements `th` and `td` are both examples of `table-cell`  elements.
- `table-caption`

####Row primacy
- columns and column groups can accept only for styles: `border`, `background`, `width`, and `visibility`

###Anonymous Table Objects
####Object insertion rules
1. If a table-cell element¡¯s parent is not a table-row element, then an anonymous table-row object is inserted between the table-cell element and its parent. The inserted object will include all consecutive siblings of the table-cell element.
2. If a table-row element¡¯s parent is not a table , inline-table , or table-row-group element, then an anonymous table element is inserted between the table-row element and its parent. The inserted object will include all consecutive siblings of the table-row element.
3. If a table-column element¡¯s parent is not a table , inline-table , or table-column- group element, then an anonymous table element is inserted between the table- column element and its parent. This is much the same as the table-row rule just discussed, except for its column-oriented nature.
4. If the parent element of a table-row-group , table-header-group , table-footer- group , table-column-group , or table-caption element is not a table element, then an anonymous table object is inserted between the element and its parent.
5. If a child element of a table or inline-table element is not a table-row-group , table-header-group , table-footer-group , table-row , or table-caption element, then an anonymous table-row object is inserted between the table element and its child element. This anonymous object spans all of the consecutive siblings of the child element that are not table-row-group , table-header-group , table- footer-group , table-row , or table-caption elements
6. If a child element of a table-row-group , table-header-group , or table-footer- group element is not a table-row element, then an anonymous table-row object is inserted between the element and its child element. This anonymous object spans all consecutive siblings of the child element that are not table-row objects themselves. 
7. If a child element of a table-row element is not a table-cell element, then an anonymous table-cell object is inserted between the element and its child ele- ment. This anonymous object encloses all consecutive siblings of the child element that are not table-cell elements themselves


###Captions
- For the most part, captions are styled just like any block-level element; they can have padding, borders, backgrounds, and so on.

###Table Cell Borders
-  two quite distinct border models: separated border model &  collapsed border model
- border-collapse:  `collapse`(default) | seperate | inherit ;
- `border-collpase` applies to elements with the `display` value `table` or `inline-table`

###Separated Cell Borders
####Handling empty cells

###Collapsing Cell Borders
- Elements with a `display` of `table` or `inline-table` cannot have any padding, although they can have margins. 
- Borders can be applied to cells, rows, row groups, columns, and column groups. The table element itself can, as always, have a border.
- There is never any seperation between cell borders. In fact, borders collapse into each other where they adjoin, so that only one of the collapsing borders is actually drawn. This is somewhat akin to margin collapsing, where the largest margin wins. When cell borders collapse, the "most interesting" border wins.
- Once they are collapsed, the borders between cells are centered on the hypothetical grid lines between the cells.

####Border collapsing
- When two or more borders are adjacent, they collapse into each other.

- If one of the collapsing borders has a `border-style` of `hidden`, it takes precedence over all other collapsing borders. All borders at this location are hidden.
- If one of the collapsing borders has a `border-style` of `none`, it takes the lowest priority. There will be no border drawn at this location unless all of the colliding borders have a value of `none`. Note that `none` is the default value for `border-style`
- If at least one of the collapsing borders has a value other than `none` and none of the collapsing borders has a value of `hidden`, then narrow borders lose out to wider ones. If more than one of the collapsing borders have the same width, then the border style is taken in the following order, from most to least preferred: `double`, `solid`, `dashed`, `dotted`, `ridge`, `outset`, `groove`, `inset`. Thus, if two borders with the same width are collapsing, and one is `dashed` while the other is `outset`, the border at that location will be dashed.
- If collapsing borders have the same style and width, but differ in color, then the color used is taken from an element in the following list, from most to least preferred: cell, row, row group, column, column group, tabel. Thus, if the borders of a cell and a column (identical in every way except color) collapse, then the cell's border color ( and style and width ) will be used. If the collapsing border come from the same type of element, such as two row borders with the same style and width but different colors, then the color is taken from borders that are the topmost and leftmost (in left-to-right languages; otherwise, topmost and rightmost)

####Fixed layout
- The fixed-layout model is so fast is that its layout does not depend on the contents of table celss. Instead, it's driven by the `width` values of the table, columns, and cells within that table.

The fixed-layout model works in the following simple steps:

1. Any column element whose `width` property has a value other than `auto` sets the width for that column
2. If a column has an `auto` width, but the cell in the first row of the table within that column has a `width` other than `auto`, then the cell sets the width for that column. If the cell spans multiple columns, the width is divided between the columns.
3. Any columns that are still auto-sized are sized so that their widths are as equal as possible


##CHAPTER 12 Lists and Generated Content

###Types of Lists
- The `list-style-type` property can be applied only to an element that has a `display` of `list-item`, but CSS doesn't distinguish between ordered and unordered list items.

###List Item Images
- `list-style-image` applies to element whose `display` value is `list-item`

###List-Marker Positions
- `list-style-position` : `inside` | `outside`(initial value) | `inherit`


###List Layout

###Inserting Generated Content
- Link border extends around the generated content. This happens because generated content is placed inside the element box of the element.

- If the subject of a `:before` or `:after` selector is a block-level element, then the property `display` can accept only the values `none`, `inline`, `block`, and `marker`. Any other value is treated as `block`
- If the subject of a `:before` or `:after` selector is an inline-level element, then the property `display` can accept only the values `none` and `inline`. Any other value is treated as `inline`


##CHAPTER 18 Scripted HTTP

XMLHttpRuquest:
	
	1. The object supports any text based format, including XML.
	2. It can be used to ake requests over both HTTP and HTTPS (some implementations support protocols in addition to HTTP and HTTPS, but that functionality is not covered by this specification)
	3. It supports "requests" in a broad sense of the term as it pertains to HTTP; namely all activity involved with HTTP requests or responses for the defined HTTP methods.


- Comet require the client to establish ( and re-establish as necessary) a connection to the server, and require the server to keep that connection open so that it can send asynchronous messages over it


###18.1 Using XMLHttpRequest
- You can reuse an existing XMLHttpRequet object, but note that doing so will abort any request pending through that object.


```javascript
	//Emulate the XMLHttpRequest() constructor in IE5 and IE6
	if(window.XMLHttpRequest === undefined){
			window.XMLHttpRequest = function(){
					try{
						//Use the latest vesion of the ActiveX object if available
						return new ActiveXObject("Msxml2.XMLHTTP.6.0");
						}
					catch(e1){
							try{
								//Otherwise fall back on an older version
								return new ActiveXObject("Msxml2.XHLHTTP.3.0");
								}
							catch(e2){
									//Otherwise, throw an error
									throw new Error("XMLHttpRuest is not supported");
								}
						}
				};
			}
```

An HTTP request consists of four parts:

	1. the HTTP request method or "verb"
	2. the URL being requested
	3. an optional set of request headers, which may include authentication information
	4. an optional request body

The HTTP response sent by a server has three parts:

	1. a numeric and textual status code that indicates the success or failure of the request
	2. a set of respons headers
	3. the response body
