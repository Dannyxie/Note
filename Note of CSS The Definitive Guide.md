#CSS: The Definitive Guide

##Chapter 1 CSS and Documents
###Elements
- `Elements` are the basis of document structure.

###Replaced and Nonreplaced Elements
- elements generally take two forms: replaced and nonreplaced

####Replaced elements
- **Replaced elements** are those where the element's content is replaced by something that is not directly represented by document content. such like `img`,`input`

####Nonreplaced elements
- **Nonreplaced elements** mean that their content is represented by the user agent(generally a browser) inside a box generated by the element itself.( This is true of paragraghs, headings, table cells, lists, and almost everything else in XHTML.)

###Element Display Roles
- In addition to replaced and nonreplaced elements, CSS2.1 uses two other basic types of elements: **block-level** and **inline-level**.

####Block-level elements
- **Block-level elements** generate an element box that(by default) fills its parent element's content area and cannot have other elements at its sides.(`p`,`dic`,etc). Replaced elements can be block-level elements, but they usually are not.
- List items are a special case of block-level elements. In additon to behaving in a manner consistent with other block elements, they generate a marker--typically a bullet for unoredered lists and a number for oreder lists--that is "attached" to the element box. Except for the represence of this marker, list items are in all other ways identical to other block elements.

####Inline-level elements
- **Inline-level elements** generate an element box within a line of text and do not break up the flow of that line ( `a`,`strong`, `em`, etc). These elements do not generate a "break" before or after themselves, so they can appear within the content of another element without disrupting its display.
  

- In HTML and XHTML, block-level elements cannot descend from inline-level elements. In CSS, there is no restriction on how display roles can be nested within each other.
- Typically, the XHTML hierarchy works out such that inlines can descend from blocks, but no the other way around. CSS, on the other hand, has no such restrictions.

###Bringing CSS and XHTML Together
- documents are supported to have an internal structure, which is altogether different than a visual structure.
 
###The link Tag
`<link rel="stylesheet" type="text/css" href="shee1.css" media="all" />`

- To successfully load an external style sheet, **link** must be placed inside the **head** element but may not be placed inside any other element, rather like title. This will cause the web browser to locate and load the style sheet and use whatever styles it contains to render the HTML document.
-  No XHTML or any other markup languague can be included in the style sheet-- only style rules.
- An external style sheet cannot contain any document markup at all, only CSS rules and CSS comments. The presence of markup in an external style sheet can cause some or all of it to be ignored.
- The filename extension is not required, but some older browser won't recognize the file as containing a style sheet unless it actually ends with **.css**. In fact, some web servers won't hand over a file as **text/css** unless its filename ends with **.css*, though that can usually be fixed by changing the server's configuration files.

####Attribute
- type is always set to **text/css**. This value describes the type of data that will be loaded using the **link** tag.

**media** attribute:
	all: Use in all presentational media
	print: Use when printing the document for sighted users and also when displaying a "print preview" of the document.
	screen: Use when presenting the document in a screen medium like a desktop computer monitor. All web browsers running on such systems are screen-medium user agents.

###The style element
- The style element should always start with `<style type="text/css">`, it is possible to be given a **media** attribute.
- The style between the opening and closing style tags are referred to  as the *document style sheet*, or the *embedded style sheet* since this style sheet is embedded within the document. 

###The @import Directive
- `@import url(sheet2.css)`
- `@import` can be used to direct to web browser to load an external style sheet and use its styles  in rendering of the HTML document. `@import` must be placed inside the `style` container
- the style sheets of every @import directive will be loaded and used; (no way to designate alternate style)
- We can restrict imported style sheets to one or more media by listing the media to which it should be applied after the style sheet's URL: `@import url(shee2.css) all;`,`@import url(blueworld.css) screen;`
- External style sheets cannot contain any document makrup, the `link` element can'y be used -- but `@import` can.
- `@import` also directives appear at the beginning of the style sheet. CSS requires the `@import` directive to come before any other rules in a style sheet. An @import that comes after other rules will be ignored by conforming user agents.
- Internet Explorer for Whindows does not ignore any @import directive, even those that come after other rules.

###Backward accesibility

###CSS Comments
`/* This is a CSS1 comment */`

###Inline Styles
- we can't put an `@import` into a `style` attribute
- Use of the `style` attribute is not generally recommended. Indeed, it is marked as deprecated by XHTML 1.1 and is very unlikely to appear in XML languages other than XHTML. Some of the primary advantages of CSS -- the ability to organize centralized styles that control an entire document's appearance or the apperance of all documents on a web server -- are negated when you place styles into a `style` attribute 
	

###Summary



##Chapter 2 Selctors

###Declarations and Keywords
- In the CSS property font, there is exactly one place where a forward slach (/) can be used to seperate two specific keywords. `h2 {font: large/150% sans-serif;}`. This is the only place the slash is allowed to appear in the `font` declaration.


###Multiple Classes
- `.warning.urgent{ background:silver;}`
- If a multiple class selector contains a name that is not in the space-separated list then the match will fail: `p.warning.help{ background:red;}` It will match a `p` element with both class `warning` and `help`: `<p class="urgent warning help">Help me!</p>
- In versions previous to IE7, Internet Explorer for both paltforms has problems with correctly handling multiple class selectos. In there older versions, although you ca select a single class name out of a list, selecting based on multiple names in a list does not work properly. Thus, `p.warning` would work as expected, but `p.warning.help` would match any `p` elements that have a `class` attribute with the word `help` because it comes last in the selector. If you wrote `p.help.warning`, then older versions of Explorer would match any `p` elements that have `warning` in their class value, whether or not `help` appears in the same value.


###Deciding Between Class and ID
- In the real world, browser don't usually check for the uniqueness of IDs in HTML, which means that if you sprinkle an HTML document with several elements, all of which have the same value for their ID attributes, you'll probably get the same styles applied to each. This is incorrect behavior, but it happens anyway. Having more that one of the same ID value in a document also makes DOM scripting more difficult, since function like `getElementById()` depend on there being one, and only one, element with a given ID value.
- ID selectors can't be combined, since ID attributes do not permit a space-separated list of words.
- class and ID selectors may be case-sensitive, depending on the document language. HTML and XHTML define class and ID values to be case-sensitive.

###Selection Based on Partial Attribute Values
- `~` is the key to selection based on the presence of a space-separated word within the attribute's value. `p[class~="warning"]{ font-weight: bold;}`

###Understanding the Parent-Child Relationship
- An element is said to be the parent of another element if it appears directly above that element in the document hierarchy
- An element is the child of another element if it is directly beneath the other element.
- THe terms parent and child are specific applications of the terms `ancestor` and `descendant`. In the tree view, if an element is exactly one level above another, then they have a parent-child relationship. If the path from one element to another continues through two or more levels, the elements have an ancestor-descendant relationship, but not a parent-child relationship.(Of course, a child is also a descendant, and a parent is an ancestor.)

###Descendant Selectors
- `:link` refers to links to resources that haven't been visited.

###Selecting Adjacent Sibling Elements
- To select an element that immediately follows another element with the same parent, you use the `adjacent-sibling combinator`, represented as a plus symbol (+).
- Internet Explorer for Windows through IE6 does not support child and adjacent-sibling selectors. IE7 supports both.

###Pseudo-Classes 
- CSS defines pseudo-classes that make the anchors to visited pages act as though thay have classes of "visited" `a:visited {color:red;}`. The colon separating the a and the visited is the calling card of a pesudo-class or pseudo-element. All pseudo-class and -element keywords are preceded by a colon.

####Link pseudo-classes

|Name|Description|
|----|----------|
|:link| Refers to any anchor that is a hyperlink(i.e., has an *href* attribute) and points to an address that has not been visited. Note that some browsers may incorrectly interpret `:link` to refer to any hyperlink, visited or unvisited.|
|:visited| Refers to any anchor that is a hyperlink to an already visited address|

 
###Dynamic pseudo-classes
|name|Description|
|----|-------|
|:focus| Refers to any element that currently has the input focus -- i.e., can accept keyboard input or be activated in some way.|
|:hover| Refers to any element over which the mouse pointer is placed --e.g., a hyperlink over which the mouse pointer is hovering.|
|:active| Refers to any element that has been activated by user input --e.g., a hyperlink on which a user clicks during the time the mouse button is held down.|

- THe dynamic pseudo-classes can be applied to any element.
- IE6 does not permit dynamic pseudo-classes to select any elements other that hyperlinks. IE7 added support for `:hover` on any element, but not `:focus` styles for form elements.

###Selecting a first child
- `:first-child`, is used to select elements that are the first children of other elements. support: IE7+

###Selecting based on language
-  In terms of its matching patterns, the `:lang()` pseudo-class is exactly like the |= attribute selector. `*:lang(fr) { font-style: italic;}`

- The primary difference between the pseudo-selector and the attribute selector is that the language information can be derived from a number of sources, some of which are outside the element itself.

###Combining pseudo-classes
- With CSS2.1, we can combine pseudo-classes in the same selector: `a:link:hover{color:red;}` exclusive pseudo-classes can to be combine together.
- IE6 just pay attention to the last of the combined pseudo-classes.

###Pseudo-Element Selectors

####Styling the first letter
- The first pseudo-element styles the first letter, and only that letter, of a block-level element. `p:first-letter { color:red;}`

####Styling the first line
- The  style is applied to  the first displayed line of text in each paragraph. This is true no matter how wide or narrow the display region is.  

####Restriction on :first-letter and :first-line
- In CSS2, the `:first-letter` and `:first-line` pseudo-element can be applied only to block-level elements such as headings or paragraphs and not to inline-level elements such as hyperlinks. In CSS2.1, `:first-letter` applies to all elements. 

Properties permitted on pseudo-elements

|:first-letter 		|	: first-line 	|
|-------------		|----------		|
|All font properties 	| All font properties 	|
| color 		| color 		|
| All background properties 		| All background properties|
| All margin properties 		| word-spacing 	|
| All padding properties 		| letter-spacing 		|
| All border properties 		| text-decoration 		|
| text-decoration 	| vertical-align 	|
| vertical-algin( if float is set to none) 	|  text-transform 	|
| text-transform 	| line-height 		|
| line-height 		| clear(CSS2 only; removed in CSS2.1 |
| float 		| text-shadow(CSS2 only)|
| letter-spacing(added in CSS2.1) |	|
| word-spacing(added in CSS2.1)	|	|
| clear(CSS2 only; removed in CSS2.1) 	|	|
| text-shadow(CSS2 only) | |

- In addition, all pseudo-elements must be placed at the very end of the selector in which they appear. Therefore, it would not be legal to write `p:first-line em` since the pseudo-element comes before the subject of the selector( the subject is the last element listed). The same rule applies to the other two pseudo-elements CSS2.1 defines.

###Summary

##CHAPTER 3 Structure and the Cascade

###Specificity

- The actual specificity of a selector is determined as follow:

	- For every ID attribute value given in the selector, add 0,1,0,0.
	- For every class attribute value, attribute selection, or pseudo-class given in the selection, add 0,0,1,0.
	- For every element and pseudo-element given in the selector, add 0,0,0,1. CSS2 contradicted itself as to whether pseudo-elemens had any specificity at all, but CSS2.1 makes it clear that they do, and this is where they belong.
	- Combinations and the universal selector do not contribute anything to the specificity ( more on these values later).


###Declarations and Specificity
- Once the specificity of a selector has been determined, the value will be conferred on all of its associated declarations.

###Universal Selector Specificity
- The universal selector does not contribute to the specificity of a selector.

###ID and Attribute Selector Specificity

###Inline Style Specificity

###Importance

###Inheritance
- Inheritance is the mechanism by which styles are applied not only to a specified element, but also to its descendants.
- background styles applied to the `body` element can be passed to the `html` element, which is the document's root element and therefore defines its canvas
- Property `border` does not inherit
- Most of the box-model properties -- including margins, padding, backgrounds, and borders -- are not inherited. 
- Inherited values have no specificity at all, not even zero specificity.

###The cascade
- The later a declaration appears in the style sheet or document, the more weight it is given. Declarations that appear in an imported style sheet are considered to come before all declarations within the style sheet that imports them.

###Sorting by Weight and Origin
- To sum up, there are five levels to consider in terms of declaration weight. ON order of most to least weight, these are:

	1. Reader important declarations.
	2. Author important declarations.
	3. Author normal declarations.
	4. Reader normal declarations
	5. User agent declarations

##CHAPTER 4 Values and Units

###Numbers
- There are two types of numbers in CSS: `interger` ("Whole" numbers) and `reals` (fractional numbers).


##CHAPTER 6 Text Properties 


###Indenting Text

	text-indent
	Values: <length> | <percentage> | inherit
	Initial value: 0
	Applies to: Block-level elements
	Inherited: Yes
	Percentages: Refer to the width of the containing block
	Computed value: For percentage values, as specified; for length values, the absolute length

- text-align can be applied to any block-level element, but it can't be applied to inline elements or on replaced elements such as images.
-  to "indent" the first line of an inline element, use left padding or margin.


###Horizontal Alignment
	text-align
	CSS2.1 values: left | center | right | justify | inherit
	CSS2 values: left | center | right | justify | <string> | inherit
	Initial value: User agent-specific; may also depend on writing direction
	Applies to: Block-level elements
	Inherited: Yes
	Computed value: As specified
	Note: CSS2 included a <string> value that was dropped from CSS2.1 due to
	a lack of implementation

![](http://i.imgur.com/yeGRrXZ.png)

- text-align does not control the alignment of elements, only their inline content. The actual elements are not shifted from one side to the other. Only the text within them is affected
- IE6 treat text-align:center as if it were the <center> element, and centers elements as well as text. This does not happen in standards mode in IE6 and later, but it persists in IE5.x and earlier.


####text-align:justify
- In justified text, both ends of a line of text are placed at the inner edge of the parent element. Then, the spacing between words and letters is
adjusted so that each line is precisely the same length. Justified text is common in the print world.


###Vertical Alignment

####The Height of Lines
- `line-height` controls the *leading*, which is the extra space bewtween lines of text above and beyond the font's size.

	line-height
	Values: <length> | <percentage> | <number> | normal | inherit
	Initial value: normal
	Applies to: All elements (but see text regarding replaced and block-level elements)
	Inherited: Yes
	Percentages: Relative to the font size of the element
	Computed value: For length and percentage values, the absolute value; otherwise, as specified

- When applied to a block-level element, `line-height` defines the minimum distance between text baselines within taht element.  

####Constructing a line
-  Every element in a line of text generates a *content* area, which is determined by the size of the font. This content area in turn generates an *inline* box that is, in the absence of any other factors, exactly equal to the content area. The leading generated by `line-height` is one of the factors that increates or decreates the height of each inline box.

###Vertically Aligning Text
- In CSS, the `vertical-align` property applies only to inline elements and replaced elements such as images and form inputs. `vertical-algin` is not an inherited property.
- `vertical-algin` does not affect the alignment of content within a **block-level** element.

####Baseline alignment
- `vertical-align: baseline` forces the baseline of an element to align with the baseline of its parent. If a vertically aligned element doesn't have a baseline--that is, if it's an image, a form input, or another replaced element--the the bottom of the element is aligned with the baseline of its parent.
- This alignment rule is important because ist causes some web browsers to always put a replaced element's bottom edge on the baseline, even if there is no other text in the line

####Superscripting and subscripting
- The declaration `vertical-align sub` causes an element to be subscripted, meaning that its baseline (or bottom, if it's a replaced element) is lowered with respect to its parent's baseline. The specification doesn't define the distance the elment is lowered, so it may vary depending on the user agent.
- `super` is the opposite of `sub`; it raises the element's baseline( or bottom of a replaced element) with respect to the parent's baseline. again, the dispance the text is raised depends on the user agent.
-  The values `sub` and `super` do not change the element's font size, so subscripted or superscripted text will no become smaller(or larger). 

####Bottom feeding
- `vertical-align:bottom` aligns the bottom of the element's inline box with the bottom of the line box.
- `vertical-align:text-bottom` refers to the bottom of the text in the line. For the purposes of this value, replaced elements, or any other kinds of non-text elements, are ignored. Instead, a "default" text box is considered. This default box is derived from the `font-size` of the parent element. The bottom of the aligned element's inline box is then aligned with the bottom of the default text box.

####Getting on top 
- Employing `vertical-align:top` has the opposite effect of bottom. Likewise, `vertical-align:text-top` is the reverse of text-bottom.



###Word Spacing and Letter Spacing

####Word Spacing
- The `word-spacing` property accepts a positive or negative length. This length is added to the standard space between words. In effect, `word-spacing` is used to modify interword spacing. Therefore, the default value of normal is the same as setting a value of zero(0).

###Spacing and Alignmenet
- The value of `word-spacing` may be influecned by the value of the property `text-align`

###Text Transformation
- `uppercase` and `lowercase` convert text into all upper- or lowercase characters. `capitalize` capitalizes only the first letter of each word.

###Text Decoration

###Text Shadow

###Handling Whitespace
- `white-space` affects the user agent's handling of space, newline, and tab characters within the document source.
- To a certain extent, default XHTML handling already does this: it collapses any whitespace down to a single space. 
- `whitespace:nowrap;` means that the only way to end a line is to insert a line-break element. If no such element is inserted, then the line will go forever, forcing the user to scroll horizontally to read whatever can't be initially displayed `<br/>` in the the browser window. 
- If an element is set to `pre-wrap`, then text within that element has whitespace sequences preserverd, but text lines are wrapped normally.  With this value, line-breaks in the source and those that are generated are also honored. `pre-line` is the opposite of `pre-wrap` and causes whitespace sequences to collapse as in normal text but honors new lines.


| Value | Whitespace | Linefeeds | Auto line wrapping |
| ----- | ----- | ----- | ----- |
| pre-line | Collapsed | Honored | Allowed |
| normal | Collapsed | Ignored | Allowed |
| nowrap | Collapsed | Ignored | Prevented |
| pre 	 | Preserved | Honored | Prevented |
| pre-wrap | Preserved | Honored | Allowed |



###Text Direction
- The `direction` property affects the writing direction of text in a block-level element, the direction of table column layout, the direction in which content horizontally overflows its element box, and the position of the last line of a fully justified element.


##CHAPTER 7 Basic Visual Fomatting
###Basic Boxes
- CSS assumes that every element generates one or more rectangular box, called `element box`. Each element box has a `content area` at its core.
- If no color is set, then the border takes on the foreground color of the element's content
- If a border style has gaps of some type, then the element's background is visible through those gaps.

###The Containing Block
- For an element in the normal, Western-style flow of text, the containing block the formed by the `content edge` of the nearest block-level, table cell, or inline-block ancestor box.


- Most elements are in the normal flow, and the only way for an element to leave it is to be floated or positioned.

###Block-level Elements
- In general the `width` of an element is defined as the distance from the left inner edge to the right inner edge, and the `height` is the distance from the inner top to the inner bottom

###Horizontal Fomatting
- The sum of the horizontal components of a block-level element box  in the normal flow always equals the `width` of the parent.

####Horizontal properties
- "seven properties": `margin-left`,`border-left`,`padding-left`,`width`,`padding-right`,`border-right`, and `margin-right`
- block-level elements nearly always have block-level elements for parents
- Only three may be set to auto: `width`, `margin-left`, `margin-right`. 
- `width` must either be set to `auto` or a nonnegative value of some type.

####Using auto
- three properties that can be applied `auto`: `width`, `margin-left`, or `margin-right`
- If you set `width`, `margin-left`, or `margin-right` to a value of `auto`, and give the remaining two properties specific values, then the property that is set to `auto` determines the length required to make the element box's width equal to the parent element's `width`.
- In the case where all three properties are set to something other than `auto` --  or, in CSS terminology, when these formatting properties have been `overconstrained`-- the `margin-right` is always forced to be `auto`.
- `margin-right` is forced to be `auto` only for **left-to-right** languages such as English. In **right-to-left** languages, everything is reversed, so `margin-left` is forced to be `auto`, not `margin-right`.
- If both margins are set explicitly, and `width` is set to `auto`, then the value of `width` will be set to whatever value is needed to reach the required total(which si the content width of the parent element).
- If both margins are set to auto, then they are set to equal lengths.
- Setting both margins to equal lengths is the correct way to center elements, as opposed to using `text-align`. ( text-align applies only to the inline content of a block-level element)
- Set one of the margins and the width to `auto`, the margin set to `auto` is reduced to zero.
- When all three properties are set to `auto`, both margins are set to zero, and the width is made as wide as possible.
- Since horizontal margins do not collapse, the paddding, borders, and margins of a parent element can affect its children. The effect is indirect in that the margins( and so on ) of an element can induce an offset for child elements.

####Negative margins
- The total of the seven horizontal properties always equals the width of the parent element. As long as all properties are zero or greater, an element can never be wider that its parent's content area.
- Padding, borders, and content widths( and heights) can never be negative. Only margins can be less that zero.

####Percentages
- Borders cannot have percentage widths, only lengths.

####Replaced elements
- Replaced block-level elements: if `width` is left as `auto`, then the width of the element is the content's intrinsic width.
- When a replaced element's width is changed from its intrinsic width, the value of height is scaled to match, unless height has been set to an explicit value of its own. The reverse is also true.

###Vertical Formatting
- The default height of an element is determined by its content. Height is also affected by the width of the content; the skinnier a paragraph becomes, the taller it must be to contain all of the inline content within it.
- When the `height` is less than what is needed to display the content, the browser may add a scrollbar to the element. ( depend on the value of the property `ovverflow`)
- `height` defines the content area's height, not the height of the visible element box. Any padding, borders, or margins on the top or bottom of the element box are added to the value for height.

####Vertical properties
- Vertical formatting has seven related properties: `margin-top`, `border-top`, `padding-top`, `height`, `padding-bottom`, `border-bottom`, and `margin-bottom`
- Only three properties may be set to auto: the height of the element's content and the top and bottom margins. The top and bottom padding and borders must be set to specific values or else they default to a width of zero. (Assuming no `border-style` is declared). If `broder-style` has been set, then the width of the borders is set to be the vaguely defined value medium.
- If either `margin-top` or `margin-bottom` is set to `auto` for a block element in the normal flow, it automatically evaluates to **0**.
- `height` must be set to `auto` or to a nonnegative value of some type.

####Percentage heights
- If the `height` of a block-level, normal-flow element is set to a percentage, then that value is taken as a percentage of the height of the containing block.
- In cases where the `height` of the containing block is not explicitly declared, percentage heights are reset to auto.


####Auto heights
- A block-level, normal-flow element with `height: auto` is rendered just hight enough to enclose the line boxed of its inline content (including text)
- auto height sets a border on a paragraph and assumes no padding--expect the bottom border to go just under the bottom line of text and the top border to go just above the top line of text.
- If an auto-height, block-level, normal-flow element has only block-level childlren, then its default height will be the distance from the top of the topmost block-level child's outer border edge to the bttom of the bottommost block-level child's outer border edge.
- If a block-level element has either top or bottom padding, or top or bottom borders, then its height will be the distance from the top of the outer top margin edge of its topmost child to the outer bottom margin edge of its bottommost child.

####Collapsing vertical margins
- Collapsing behavior applies only to margins. Padding and borders, where they exist, are never collapsed by anything.(overlap)
- The smaller of the two magins is eliminated in favor of the larger

####Negative margins
- If negative vertical margins are set, then the browser should take the absolute maximum of both margins. The absolute value of the negative margin is then substracted from the positive margin. In other words, the negative is added to the positive, and the resulting value is the distance between the elements.


###Inline Elements
- The content area is analogous to the content box of a block-level element.
- The background of an inline element is applied to the content area plus any padding
- Any border on an inline element surrounds the content area plus any padding and broders.
- Padding, borders, and margins on nonreplaced elements have no vertical effect on inline elements or the boxes they generate; that is, they do no affect the height of an elements's inline box( and thus the line box that contains the elements).
- Margins and borders on replaced elements do affect the height of the inline box for that elemen and, by implication, the height of the line box for the line containing the element.
- Inline boxes are vertically aligned within the line according to their values for the property `vertical-align`


###Basic Term and Concepts
- For nonreplaced elements, the height of the **inline box** of an element will be exactly equal to the value for `line-height`. For replaced elements, the height of the inline box of an element will be exactly equal to the content area since leading is not applied to replaced elements.
- The top edge of the **line box** is placed along the top of the highest inline box top, and the bottom of the **line box**  is placed along the bottom of the lowest inline box bottom

###Inline Formatting
- All elements have a `line-height`
- A line's height ( or the height of the line box) is determined by the height of its constituent elements and other content, such as text.
- `line-height` actually affects inline elements and other inline content, not block-elements--at least, not directly.
- Declaring `line-height` on a block-level element sets a minimum line-box height for the content of that block-level element.

###Inline Nonreplaced Elements

####Building the boxes
- For an inline nonreplaced element or pieve of anonymous text, the value of `font-size` determines the height of the conent area.
- The line box is defined as the distance from the top of the highest inline box in the line to the bottom of the lowest inline box, and the top of each line box butts up against the bottom of the line box for the preceding line.

####Vertical alignment

The effects of the assorted keyword values of `vertical-align` are:
	top: Aligns the top of the element's inline box with the top of the containing line box.
	bottom: Aligns the bottom of the element's inline box with the bottom of the containing line box.
	text-top: Aligns the top of the element's inline box with the top of the parent's content area.
	text-bottom: Aligns the bottom of the element's inline box with the bottom of the parent's content area.
	middle: Algins the vertical midpoint of the element's inline box with a poing one-half ex above the baseline of the parent.
	super: Moves the content area and inline box of the element upward. The distance is not specified and may vary by user agent.
	sub: The same as super, except the element is moved downward instead of upward
	<percentage> : Shifts the element up or down the distance defined by taking the declared percentage of the element's value of `line-height`



###Inline Replaced Element
- Inline replaced element, such as images, are assumed to have an intrinsic height and width.
- A replaced element with an intrinsic height can cause a line box to become taller than normal. This does no change the value of `line-height` for any element in the line, including the replaced element itself. Replaced element can increase the height of the line box but not the value of line height.

####Adding box properties
- Padding and borders are applied to replaced elements as usual; These two thing acutally influence the height of the line box because they are part of the inline box of an line replaced element( unlike inline nonreplaced elements)
- Negative margins are the only way  to cause inline replaced elements to bleed into other lines.

####Replaced elements and the baseline
- Replaced elements do not actually have baselines of their own, so the next best thing is to align the bottom of their inline boxes with the baseline.
- An image placed in a table cell all by itself should make the table cell tall enough to contain the line box containing the image


###Inline-Block Elements
- An inline-block element relates to other elements and content as an inline box. In other words, it's laid out in a line of text just as an image would be, and, in fact, inline-block elements are formatted within a line as a replaced element. This means the bottom of the inline-blovk element will rest on the baseline of the text line by default and will not line-break within itself.
- Inside the inline-blovk element, the content is formatted as thought the element were block-level.
- If an inline-block element's width is not defined or explicitly declared auto, the element box will shrink to fit the content.

##CHAPTER 8 Padding, Borders, and Margins

###Basic Element Boxes
- Boxes can overlap if they have been manually positioned, and visual overlap can occur if negative margins are used on normal-flow elements.

###Width and Height
- `width` and `height` don't apply to inline-nonreplaced elements. (they apply to Block-level and replaced elements)

Problem( Both of these behaviors were fixed in IE6, but only in "standard" mode. "quirks" mode will still use the previously described behaviors.):
	
	- IE/Win used `width` and `height` to define the dimensions of the visible element box, not the content of the element box. In other words, IE6/Win used `width` to describe the total of the element's content area, left and right padding, and left and right border.
	- IE/Win applied `width` and `height` to inline nonreplaced elements.


